from __future__ import annotations

import argparse
import os
import re
import subprocess
import sys
from pathlib import Path
from typing import Optional, Sequence

import yaml


DEFAULT_SERVER_PORT = 5001
DEFAULT_SERVER_IP = "YOUR_SERVER_IP"


def _repo_root() -> Path:
    return Path(__file__).resolve().parents[1]


def _server_dir(root: Path) -> Path:
    return root / "server"


def _server_entrypoint(root: Path) -> Path:
    return _server_dir(root) / "server.py"


def _server_config_path(root: Path) -> Path:
    return _server_dir(root) / "config.yaml"


def _device_dir(root: Path) -> Path:
    return root / "arduino" / "atom_echo_m5stack_esp32_ino"


def _device_secrets_path(root: Path) -> Path:
    return _device_dir(root) / "device_secrets.h"


def _device_secrets_example_path(root: Path) -> Path:
    return _device_dir(root) / "device_secrets.h.example"


def _escape_cpp_string(value: str) -> str:
    return value.replace("\\", "\\\\").replace('"', '\\"')


def _extract_server_ip(contents: str) -> Optional[str]:
    match = re.search(r'const\s+char\*\s+SERVER_IP\s*=\s*"([^"]*)"\s*;', contents)
    if not match:
        return None
    extracted = match.group(1).strip()
    return extracted or None


def _detect_server_ip(root: Path) -> str:
    for candidate in (_device_secrets_path(root), _device_secrets_example_path(root)):
        if not candidate.exists():
            continue
        content = candidate.read_text(encoding="utf-8")
        detected = _extract_server_ip(content)
        if detected:
            return detected
    return DEFAULT_SERVER_IP


def _validate_port(port: int) -> int:
    if not 1 <= port <= 65535:
        raise ValueError("port must be between 1 and 65535")
    return port


def _load_yaml_dict(path: Path) -> dict:
    if not path.exists():
        return {}
    data = yaml.safe_load(path.read_text(encoding="utf-8"))
    return data if isinstance(data, dict) else {}


def _save_yaml_dict(path: Path, data: dict) -> None:
    path.write_text(
        yaml.safe_dump(data, allow_unicode=True, sort_keys=False),
        encoding="utf-8",
    )


def _write_device_secrets(root: Path, ssid: str, password: str, port: int) -> Path:
    path = _device_secrets_path(root)
    path.parent.mkdir(parents=True, exist_ok=True)

    server_ip = _detect_server_ip(root)
    content = (
        "// Auto-generated by ccoli CLI.\n"
        "// Local credentials only. Do not commit real secrets.\n\n"
        "#ifndef DEVICE_SECRETS_H\n"
        "#define DEVICE_SECRETS_H\n\n"
        "#include <stdint.h>\n\n"
        f'const char* SSID = "{_escape_cpp_string(ssid)}";\n'
        f'const char* PASS = "{_escape_cpp_string(password)}";\n'
        f'const char* SERVER_IP = "{_escape_cpp_string(server_ip)}";\n'
        f"const uint16_t SERVER_PORT = {port};\n\n"
        "#endif  // DEVICE_SECRETS_H\n"
    )
    path.write_text(content, encoding="utf-8")
    return path


def _update_server_port(root: Path, port: int) -> Path:
    config_path = _server_config_path(root)
    config_path.parent.mkdir(parents=True, exist_ok=True)

    config_data = _load_yaml_dict(config_path)
    server_cfg = config_data.setdefault("server", {})
    if not isinstance(server_cfg, dict):
        server_cfg = {}
        config_data["server"] = server_cfg

    server_cfg["port"] = port
    if "host" not in server_cfg:
        server_cfg["host"] = "0.0.0.0"

    _save_yaml_dict(config_path, config_data)
    return config_path


def _parse_wifi_config_tokens(tokens: Sequence[str]) -> tuple[str, str, int]:
    cleaned = [token.strip() for token in tokens if token and token.strip()]
    if not cleaned:
        raise ValueError("missing wifi configuration tokens")

    lowered = [token.lower() for token in cleaned]
    if "password" not in lowered:
        raise ValueError("keyword `password` is required")

    password_idx = lowered.index("password")
    ssid = " ".join(cleaned[:password_idx]).strip()
    if not ssid:
        raise ValueError("wifi name is missing before `password`")

    tail_tokens = cleaned[password_idx + 1 :]
    if not tail_tokens:
        raise ValueError("password value is missing")

    tail_lowered = [token.lower() for token in tail_tokens]
    port = DEFAULT_SERVER_PORT
    if "port" in tail_lowered:
        port_idx = tail_lowered.index("port")
        password_tokens = tail_tokens[:port_idx]
        port_tokens = tail_tokens[port_idx + 1 :]
        if not port_tokens:
            raise ValueError("port value is missing")
        if len(port_tokens) != 1:
            raise ValueError("port accepts one numeric value")
        try:
            port = _validate_port(int(port_tokens[0]))
        except ValueError as exc:
            raise ValueError("port must be a valid integer between 1 and 65535") from exc
    else:
        password_tokens = tail_tokens

    password = " ".join(password_tokens).strip()
    if not password:
        raise ValueError("password value is missing")

    return ssid, password, port


def _cmd_start(port: Optional[int]) -> int:
    root = _repo_root()
    server_entry = _server_entrypoint(root)
    server_dir = _server_dir(root)

    if not server_entry.exists():
        print(f"error: server entrypoint not found: {server_entry}", file=sys.stderr)
        return 1

    env = os.environ.copy()
    if port is not None:
        env["SERVER_PORT"] = str(_validate_port(port))

    command = [sys.executable, str(server_entry)]
    try:
        completed = subprocess.run(command, cwd=str(server_dir), env=env, check=False)
    except FileNotFoundError:
        print("error: python executable is not available", file=sys.stderr)
        return 1
    return completed.returncode


def _cmd_config_wifi(tokens: Sequence[str]) -> int:
    try:
        ssid, password, port = _parse_wifi_config_tokens(tokens)
    except ValueError as exc:
        print(f"error: {exc}", file=sys.stderr)
        print(
            "usage: ccoli config wifi <WiFi Name> password <password> port <port>",
            file=sys.stderr,
        )
        return 2

    root = _repo_root()
    config_path = _update_server_port(root, port)
    secrets_path = _write_device_secrets(root, ssid, password, port)

    print(f"updated: {config_path}")
    print(f"updated: {secrets_path}")
    print("note: update SERVER_IP in device_secrets.h if it does not match your server host")
    return 0


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(prog="ccoli")
    subparsers = parser.add_subparsers(dest="command", required=True)

    start_parser = subparsers.add_parser("start", help="start the ccoli server")
    start_parser.add_argument(
        "--port",
        type=int,
        default=None,
        help=f"override server port for this run (default: {DEFAULT_SERVER_PORT})",
    )

    config_parser = subparsers.add_parser("config", help="configure ccoli project settings")
    config_subparsers = config_parser.add_subparsers(dest="config_command", required=True)

    wifi_parser = config_subparsers.add_parser("wifi", help="set wifi/password/port for ESP32 + server")
    wifi_parser.add_argument(
        "tokens",
        nargs=argparse.REMAINDER,
        help="syntax: <WiFi Name> password <password> port <port>",
    )

    return parser


def main(argv: Optional[Sequence[str]] = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)

    if args.command == "start":
        return _cmd_start(args.port)
    if args.command == "config" and args.config_command == "wifi":
        return _cmd_config_wifi(args.tokens)

    parser.print_help()
    return 1


if __name__ == "__main__":
    raise SystemExit(main())
