# LLM Arduino 전체 기능 가이드

> **프로젝트 개요**: M5Stack Atom Echo(ESP32)를 이용한 음성 인식 기반 로봇 제어 및 AI 어시스턴트 시스템

---

## 📑 목차

1. [초기 설정 및 준비](#1-초기-설정-및-준비)
2. [기본 연결 및 통신 기능](#2-기본-연결-및-통신-기능)
3. [음성 입출력 기능](#3-음성-입출력-기능)
4. [로봇 제어 기능](#4-로봇-제어-기능)
5. [AI 대화 어시스턴트 기능](#5-ai-대화-어시스턴트-기능)
6. [정보 서비스 기능](#6-정보-서비스-기능)
7. [일정 관리 기능](#7-일정-관리-기능)
8. [감정 표현 시스템](#8-감정-표현-시스템)
9. [프로액티브 상호작용](#9-프로액티브-상호작용)
10. [시스템 관리 및 모니터링](#10-시스템-관리-및-모니터링)

---

## 1. 초기 설정 및 준비

### 1.1 하드웨어 준비

#### 1.1.1 필수 하드웨어
- **M5Stack Atom Echo**: ESP32 기반 마이크/스피커 내장 장치
- **서보 모터**: 0-180도 회전 가능한 표준 서보 (선택사항)
- **PC/서버**: GPU 권장 (CUDA 지원 시 성능 향상)
- **WiFi 네트워크**: 2.4GHz 대역 지원

#### 1.1.2 하드웨어 연결
- Atom Echo의 서보 핀(G26)에 서보 모터 연결
- USB-C 케이블로 전원 공급
- WiFi 네트워크에 연결 가능한 환경 준비

### 1.2 서버 환경 설정

#### 1.2.1 Python 환경 구성
```bash
# Python 3.9 이상 필요
python --version

# 가상환경 생성 (권장)
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate

# 의존성 설치
cd server
pip install -r requirements.txt
```

#### 1.2.2 필수 패키지 설치
- **faster-whisper**: 음성 인식 (STT)
- **transformers**: LLM 모델 로딩
- **edge-tts**: 음성 합성 (TTS)
- **torch**: 딥러닝 프레임워크
- **numpy, librosa**: 오디오 처리
- **requests**: 날씨 API 호출
- **feedparser**: 뉴스 RSS 파싱
- **python-dotenv**: 환경 변수 관리

### 1.3 설정 파일 구성

#### 1.3.1 서버 설정 (config.yaml)
```yaml
server:
  host: "0.0.0.0"      # 모든 인터페이스에서 수신
  port: 5001           # TCP 서버 포트

stt:
  model_size: "small"  # STT 모델 크기 선택
  device: "cuda"       # GPU 사용 (cuda/cpu)
  language: "ko"       # 한국어 인식

assistant:
  name: "아이"         # 어시스턴트 이름
  personality: "cheerful"  # 성격 설정
```

#### 1.3.2 환경 변수 설정 (.env)
```bash
# .env 파일 생성
WEATHER_API_KEY=your_api_key_here
SERVER_PORT=5001
DEVICE=cuda
LOG_LEVEL=INFO
```

#### 1.3.3 Arduino 설정 (config.h)
```cpp
// WiFi 설정
#define WIFI_SSID "your_wifi_name"
#define WIFI_PASS "your_wifi_password"

// 서버 설정
#define SERVER_IP "192.168.1.100"  // PC의 IP 주소
#define SERVER_PORT 5001

// 하드웨어 설정
#define SERVO_PIN 26
#define LED_PIN 27
```

### 1.4 초기 실행

#### 1.4.1 서버 시작
```bash
cd server
python server.py
```

**실행 확인 사항**:
- STT 모델 로딩 완료
- LLM 모델 로딩 완료
- TCP 서버 5001번 포트 리스닝
- 설정 파일 로드 성공

#### 1.4.2 Arduino 업로드
1. Arduino IDE에서 프로젝트 열기
2. 보드 선택: ESP32 Dev Module 또는 M5Stack Atom
3. 포트 선택
4. 업로드 실행
5. 시리얼 모니터로 연결 확인

---

## 2. 기본 연결 및 통신 기능

### 2.1 네트워크 연결

#### 2.1.1 WiFi 연결
- ESP32가 부팅 시 자동으로 WiFi 연결 시도
- 연결 성공 시 LED가 파란색으로 변경
- 연결 실패 시 5초마다 재시도

**사용자 확인 방법**:
- 시리얼 모니터에서 "WiFi connected" 메시지 확인
- LED 색상 확인 (파란색 = 연결 성공)

#### 2.1.2 서버 연결
- WiFi 연결 후 자동으로 서버에 TCP 연결 시도
- 연결 성공 시 LED가 초록색으로 변경
- 연결 실패 시 5초마다 재시도

**사용자 확인 방법**:
- 시리얼 모니터에서 "Server connected" 메시지
- LED가 초록색으로 변경
- 서버 로그에 "Client connected" 메시지

#### 2.1.3 연결 유지 (Keepalive)
- ESP32가 3초마다 PING 패킷 전송
- 서버 응답 없을 시 재연결 시도
- 네트워크 끊김 자동 복구

### 2.2 프로토콜 통신

#### 2.2.1 패킷 구조
모든 데이터는 다음 형식으로 전송됩니다:
- **1바이트**: 패킷 타입
- **2바이트**: 페이로드 길이 (Little Endian)
- **N바이트**: 실제 데이터

#### 2.2.2 ESP32 → 서버 패킷 타입
- `0x01 START`: 음성 녹음 시작
- `0x02 AUDIO`: PCM 오디오 데이터 (320 샘플)
- `0x03 END`: 음성 녹음 종료
- `0x10 PING`: 연결 유지 신호

#### 2.2.3 서버 → ESP32 패킷 타입
- `0x11 CMD`: JSON 형식 명령
- `0x12 AUDIO_OUT`: TTS 오디오 출력
- `0x1F PONG`: PING 응답 (선택사항)

### 2.3 연결 테스트

#### 2.3.1 수동 연결 테스트
- Arduino 시리얼 모니터에서 연결 상태 확인
- 서버 로그에서 클라이언트 연결 확인
- LED 색상으로 상태 확인

#### 2.3.2 통신 테스트
- 짧은 소리(박수, 말소리 등)를 내어 음성 감지 확인
- 서버 로그에 "Audio received" 메시지 확인
- 양방향 통신 정상 작동 확인

---

## 3. 음성 입출력 기능

### 3.1 음성 입력 (STT)

#### 3.1.1 음성 활동 감지 (VAD)
**기능 설명**: 사용자의 말소리를 자동으로 감지하여 녹음을 시작합니다.

**동작 방식**:
- 마이크로 실시간 오디오 모니터링
- RMS(Root Mean Square) 값으로 음량 측정
- 임계값 초과 시 음성으로 판단
- 프리롤 버퍼(200ms) 포함하여 전송

**사용자 경험**:
- 버튼을 누를 필요 없이 자동으로 감지
- 작은 소음은 무시하고 말소리만 인식
- 말을 시작하면 LED가 빨간색으로 변경

#### 3.1.2 음성 녹음
**기능 설명**: 감지된 음성을 고품질로 녹음하여 서버로 전송합니다.

**오디오 스펙**:
- 샘플레이트: 16kHz
- 비트 깊이: 16-bit
- 채널: 모노
- 프레임 크기: 320 샘플 (20ms)

**녹음 파라미터**:
- 최소 녹음 시간: 300ms
- 최대 녹음 시간: 12초
- 침묵 감지 시간: 600ms (침묵이 이 시간 이상 지속되면 종료)

**사용자 경험**:
1. 말을 시작하면 자동 녹음 시작
2. LED가 빨간색으로 변경
3. 말을 마치고 잠시 침묵하면 자동 종료
4. LED가 원래 색으로 복귀

#### 3.1.3 음성 인식 (Whisper STT)
**기능 설명**: 녹음된 음성을 텍스트로 변환합니다.

**STT 엔진 옵션**:
- `tiny`: 가장 빠름, 정확도 낮음 (39MB)
- `base`: 빠름, 적당한 정확도 (74MB)
- `small`: 균형 잡힌 선택 (244MB) - **기본값**
- `medium`: 느림, 높은 정확도 (769MB)
- `large`: 매우 느림, 최고 정확도 (1550MB)

**처리 과정**:
1. 오디오 품질 검사 (RMS, Peak 값)
2. 무음 구간 제거
3. 볼륨 정규화
4. Whisper 모델로 인식
5. 결과 텍스트 반환

**성능**:
- GPU 사용 시: 0.5~1초
- CPU 사용 시: 2~5초

#### 3.1.4 음질 검증
**기능 설명**: 녹음된 오디오의 품질을 자동으로 검사합니다.

**검증 항목**:
- **RMS 값**: 전체 음량 수준 (최소 100 이상)
- **Peak 값**: 최대 진폭 (최소 500 이상)
- **길이**: 최소 녹음 시간 충족 여부

**실패 시 동작**:
- 음성 인식 건너뜀
- 서버 로그에 경고 메시지
- 사용자에게 다시 말하도록 유도

### 3.2 음성 출력 (TTS)

#### 3.2.1 텍스트 음성 변환
**기능 설명**: AI의 응답 텍스트를 자연스러운 음성으로 변환합니다.

**TTS 엔진**: Microsoft Edge TTS
- **기본 음성**: ko-KR-SunHiNeural (여성)
- **대체 음성**: ko-KR-InJoonNeural (남성)
- **품질**: 고품질, 자연스러운 억양

**지원 기능**:
- 빠른 변환 속도 (1~2초)
- 인터넷 연결 필요
- 무료 사용 가능

#### 3.2.2 오디오 스트리밍
**기능 설명**: 생성된 음성을 ESP32로 실시간 전송하여 재생합니다.

**스트리밍 방식**:
- 청크 크기: 2048 바이트 (1024 샘플)
- 전송 간격: 10ms
- 형식: 16kHz PCM16LE 모노

**버퍼 관리**:
- ESP32 링 버퍼: 32KB
- 최소 재생 버퍼: 4KB
- 비블로킹 재생 방식

**사용자 경험**:
1. AI 응답 생성 완료 후 즉시 재생 시작
2. 끊김 없는 부드러운 재생
3. 재생 중에도 새로운 음성 입력 가능

#### 3.2.3 볼륨 정규화
**기능 설명**: 출력 음성의 볼륨을 일정하게 유지합니다.

**정규화 과정**:
- Peak 값 측정
- 목표 볼륨으로 스케일링 (70% 수준)
- 클리핑 방지
- 일관된 청취 경험 제공

---

## 4. 로봇 제어 기능

### 4.1 로봇 모드 개요

#### 4.1.1 로봇 모드란?
**기능 설명**: 음성 명령으로 서보 모터를 제어하는 모드입니다.

**특징**:
- 짧고 명확한 명령 중심
- 즉각적인 동작 실행
- 대화 없이 명령만 수행
- 서보 모터 위치 제어

**활용 사례**:
- 카메라 방향 조절
- 로봇 팔/머리 움직임
- 센서 방향 제어
- 물리적 포인팅

### 4.2 기본 서보 제어

#### 4.2.1 고정 위치 이동
**기능 설명**: 미리 정의된 위치로 서보를 이동시킵니다.

**지원 명령**:

1. **중앙 위치 (90도)**
   - 명령어: "가운데", "중앙", "센터", "원위치"
   - 용도: 기본 위치로 복귀
   - 예시: "가운데로 가"

2. **왼쪽 위치 (30도)**
   - 명령어: "왼쪽", "좌측", "좌"
   - 용도: 왼쪽 방향 지시
   - 예시: "왼쪽으로 돌려"

3. **오른쪽 위치 (150도)**
   - 명령어: "오른쪽", "우측", "우"
   - 용도: 오른쪽 방향 지시
   - 예시: "오른쪽 봐"

**동작 특성**:
- 즉각적인 이동
- LED로 상태 표시
- 부드러운 모션

#### 4.2.2 상대 위치 조정
**기능 설명**: 현재 위치에서 일정 각도만큼 이동합니다.

**지원 명령**:

1. **위로 이동 (+20도)**
   - 명령어: "올려", "위로", "업"
   - 용도: 각도 증가
   - 예시: "조금 올려"

2. **아래로 이동 (-20도)**
   - 명령어: "내려", "아래로", "다운"
   - 용도: 각도 감소
   - 예시: "더 내려"

**동작 특성**:
- 현재 각도에서 상대 이동
- 범위 제한 (0~180도)
- 연속 명령 가능

#### 4.2.3 각도 직접 지정
**기능 설명**: 원하는 각도를 숫자로 직접 지정합니다.

**지원 형식**:
1. "숫자 + 도": "45도", "120도"
2. "숫자만": "45", "120"

**예시**:
- "45도로 가"
- "120"
- "90도로 돌려"

**동작 특성**:
- 0~180도 범위 내 정확한 위치
- 범위 초과 시 자동 제한
- 1도 단위 정밀 제어

### 4.3 동작 제어

#### 4.3.1 정지 명령
**기능 설명**: 현재 진행 중인 동작을 즉시 멈춥니다.

**명령어**: "멈춰", "정지", "스탑"

**사용 상황**:
- 회전 중 긴급 정지
- 의도하지 않은 동작 중단
- 안전을 위한 정지

#### 4.3.2 회전 동작
**기능 설명**: 서보를 좌우로 왕복 회전시킵니다.

**명령어**: "회전", "돌아", "돌려"

**동작 방식**:
- 30도 ↔ 150도 반복
- 부드러운 왕복 운동
- 정지 명령으로 중단 가능

**활용 예시**:
- 주변 환경 스캔
- 주의 환기
- 동작 데모

### 4.4 명령 처리 방식

#### 4.4.1 키워드 매칭
**기능 설명**: 미리 정의된 키워드를 인식하여 명령을 실행합니다.

**처리 과정**:
1. 음성 인식으로 텍스트 추출
2. `commands.yaml`의 키워드 목록과 비교
3. 매칭되는 명령 찾기
4. 해당 액션 실행

**장점**:
- 빠른 응답 속도
- 높은 정확도
- 오프라인 가능

#### 4.4.2 LLM 해석
**기능 설명**: 키워드 매칭 실패 시 AI가 의도를 파악하여 명령을 생성합니다.

**처리 과정**:
1. 키워드 매칭 실패
2. LLM에 텍스트 전달
3. AI가 의도 분석
4. JSON 명령 생성
5. 명령 실행

**예시**:
- 입력: "저쪽을 가리켜"
- LLM 해석: {"action": "SERVO_SET", "angle": 150}

**장점**:
- 자연스러운 표현 이해
- 컨텍스트 파악
- 유연한 명령 처리

#### 4.4.3 텍스트 정제
**기능 설명**: STT 결과의 오류를 LLM이 자동으로 수정합니다.

**수정 항목**:
- 오타 교정
- 띄어쓰기 수정
- 문맥 맞춤법
- 명령어 정규화

**예시**:
- 입력: "우른쪽으로가"
- 정제: "오른쪽으로 가"

### 4.5 LED 피드백

#### 4.5.1 상태 표시
**색상별 의미**:
- **빨간색**: 음성 녹음 중
- **초록색**: 서버 연결 정상
- **파란색**: WiFi 연결 중
- **노란색**: 명령 실행 중
- **흰색**: 대기 중

#### 4.5.2 동작 피드백
**기능 설명**: 명령 실행 시 LED로 시각적 피드백을 제공합니다.

**패턴**:
- 명령 수신: 짧은 깜빡임
- 실행 중: 지속 점등
- 완료: 원래 색으로 복귀

---

## 5. AI 대화 어시스턴트 기능

### 5.1 에이전트 모드 개요

#### 5.1.1 에이전트 모드란?
**기능 설명**: AI와 자연스러운 대화를 나누는 모드입니다.

**특징**:
- 자유로운 대화 가능
- 컨텍스트 기억
- 감정 이해
- 개성 있는 응답
- 음성 응답 제공

**활용 사례**:
- 일상 대화
- 정보 질문
- 감정 공유
- 조언 요청

### 5.2 대화 기능

#### 5.2.1 자연어 대화
**기능 설명**: 사람처럼 자연스럽게 대화합니다.

**지원 기능**:
- 질문 응답
- 의견 제시
- 공감 표현
- 격려 및 위로
- 유머 및 농담

**대화 예시**:
```
사용자: "오늘 날씨 좋다"
AI: "정말 좋네요! 이런 날은 산책하기 딱이죠."

사용자: "오늘 기분이 안 좋아"
AI: "무슨 일 있었나요? 이야기해주면 도움이 될까요?"

사용자: "재미있는 얘기 해줘"
AI: "알겠어요! 컴퓨터가 왜 안경을 썼을까요? 화면이 잘 안 보여서요!"
```

#### 5.2.2 컨텍스트 유지
**기능 설명**: 이전 대화를 기억하고 문맥을 이해합니다.

**기억 범위**:
- 최근 20개 대화 저장
- 중요 정보 장기 기억
- 대화 세션 유지
- 자동 백업 및 복원

**컨텍스트 활용 예시**:
```
사용자: "내일 회의 있어"
AI: "알겠습니다. 회의 일정 저장했어요."

[다음날]
사용자: "오늘 뭐 했지?"
AI: "오늘은 회의 일정이 있으시네요!"
```

#### 5.2.3 멀티턴 대화
**기능 설명**: 여러 차례 주고받는 대화를 자연스럽게 처리합니다.

**예시**:
```
사용자: "영화 추천해줘"
AI: "어떤 장르를 좋아하세요?"

사용자: "액션"
AI: "최근 개봉한 액션 영화 중에 '미션 임파서블'은 어떠세요?"

사용자: "다른 건?"
AI: "그럼 '탑건 매버릭'도 재미있어요. 실제 전투기 장면이 멋져요."
```

### 5.3 LLM 엔진

#### 5.3.1 모델 사양
**사용 모델**: Qwen2.5-0.5B-Instruct

**특징**:
- 경량 모델 (500MB)
- 빠른 응답 속도
- 한국어 지원
- 로컬 실행 가능

**성능**:
- GPU 사용 시: 0.2~0.5초
- CPU 사용 시: 0.5~2초
- 메모리: 1~2GB

#### 5.3.2 프롬프트 엔지니어링
**기능 설명**: 성격에 맞는 시스템 프롬프트를 자동으로 생성합니다.

**성격별 프롬프트**:

1. **cheerful (밝고 활발)**
   - 긍정적이고 친근한 말투
   - 이모티콘 사용
   - 격려와 응원

2. **calm (차분하고 안정적)**
   - 차분하고 안정적인 말투
   - 신중한 조언
   - 깊이 있는 대화

3. **playful (장난기 있고 유쾌)**
   - 재미있고 장난스러운 말투
   - 농담과 유머
   - 가벼운 대화

4. **serious (진지하고 전문적)**
   - 공손하고 전문적인 말투
   - 정확한 정보 제공
   - 격식 있는 대화

#### 5.3.3 응답 생성
**기능 설명**: 대화 히스토리와 현재 입력을 바탕으로 응답을 생성합니다.

**생성 과정**:
1. 사용자 입력 수신
2. 대화 히스토리 로드
3. 컨텍스트 구성
4. LLM 추론
5. 응답 생성
6. 히스토리 업데이트

**품질 관리**:
- 최대 길이 제한 (200 토큰)
- 반복 방지
- 적절한 마무리
- 문맥 일관성

### 5.4 개성 커스터마이징

#### 5.4.1 이름 설정
**기능 설명**: 어시스턴트의 이름을 자유롭게 설정할 수 있습니다.

**설정 방법** (`config.yaml`):
```yaml
assistant:
  name: "토리"  # 원하는 이름으로 변경
```

**효과**:
- 대화에서 이름 사용
- 개인화된 경험
- 친근감 증가

#### 5.4.2 성격 변경
**기능 설명**: 4가지 성격 중 선택할 수 있습니다.

**설정 방법** (`config.yaml`):
```yaml
assistant:
  personality: "playful"  # cheerful, calm, playful, serious
```

**성격별 특징**:
- **cheerful**: 친구 같은 느낌
- **calm**: 상담사 같은 느낌
- **playful**: 장난꾸러기 친구 느낌
- **serious**: 비서 같은 느낌

#### 5.4.3 TTS 음성 변경
**기능 설명**: 음성 출력의 음색을 변경할 수 있습니다.

**설정 방법** (`config.yaml`):
```yaml
tts:
  voice: "ko-KR-InJoonNeural"  # 남성 음성
  # 또는
  voice: "ko-KR-SunHiNeural"   # 여성 음성 (기본)
```

**지원 음성**:
- ko-KR-SunHiNeural: 친근한 여성 음성
- ko-KR-InJoonNeural: 차분한 남성 음성

### 5.5 대화 저장 및 복원

#### 5.5.1 자동 저장
**기능 설명**: 대화 내용을 자동으로 저장합니다.

**저장 시점**:
- 10개 대화마다 자동 백업
- 서버 종료 시 저장
- 중요 정보 즉시 저장

**저장 위치**: `context_backup.json`

#### 5.5.2 컨텍스트 복원
**기능 설명**: 서버 재시작 시 이전 대화를 자동으로 복원합니다.

**복원 내용**:
- 대화 히스토리
- 장기 기억
- 사용자 정보
- 일정 데이터

**사용자 경험**:
- 연속성 있는 대화
- 정보 유실 방지
- 자연스러운 재개

---

## 6. 정보 서비스 기능

### 6.1 시간 정보

#### 6.1.1 현재 시간 조회
**기능 설명**: 현재 시각을 자연스럽게 알려줍니다.

**명령 예시**:
- "지금 몇 시야?"
- "현재 시각 알려줘"
- "시간 좀 봐줘"

**응답 예시**:
```
"현재 시각은 2026년 2월 3일 오후 3시 30분, 화요일입니다."
```

**제공 정보**:
- 년/월/일
- 시/분
- 요일
- 오전/오후

#### 6.1.2 날짜 정보
**기능 설명**: 오늘 날짜를 알려줍니다.

**명령 예시**:
- "오늘 날짜가 뭐야?"
- "며칠이지?"
- "오늘 몇 일이야?"

**응답 형식**:
- "오늘은 2026년 2월 3일 화요일입니다."

### 6.2 날씨 정보

#### 6.2.1 현재 날씨
**기능 설명**: OpenWeatherMap API를 통해 실시간 날씨를 조회합니다.

**명령 예시**:
- "오늘 날씨 어때?"
- "날씨 알려줘"
- "밖에 춥니?"

**제공 정보**:
- 날씨 상태 (맑음, 흐림, 비, 눈 등)
- 현재 기온
- 체감 온도
- 습도
- 바람 속도

**응답 예시**:
```
"서울의 현재 날씨는 맑음입니다. 
기온은 5.2도, 체감온도는 3.1도이며, 
습도는 45%입니다."
```

#### 6.2.2 설정 방법
**API 키 발급**:
1. https://openweathermap.org/ 접속
2. 무료 계정 생성
3. API 키 발급 (무료)
4. `.env` 파일에 추가

**설정 파일** (`.env`):
```bash
WEATHER_API_KEY=your_api_key_here
```

**위치 설정** (`config.yaml`):
```yaml
weather:
  api_key: ""  # 또는 .env에서 로드
  location: "Seoul"  # 도시명 (영문)
```

### 6.3 뉴스 정보

#### 6.3.1 헤드라인 조회
**기능 설명**: RSS 피드를 통해 최신 뉴스 헤드라인을 조회합니다.

**명령 예시**:
- "뉴스 알려줘"
- "오늘 뉴스 뭐야?"
- "최신 뉴스는?"

**제공 내용**:
- 최신 3개 헤드라인 (기본)
- 뉴스 출처
- 간단한 요약

**응답 예시**:
```
"최신 뉴스입니다.
1. [경제] 주식시장 상승세 지속
2. [정치] 새로운 정책 발표
3. [사회] 날씨 변화에 주의"
```

#### 6.3.2 뉴스 소스
**기본 소스**: Google News RSS (한국)

**커스터마이징**: `info_services.py`에서 RSS URL 변경 가능

### 6.4 타이머 및 알람

#### 6.4.1 타이머 설정
**기능 설명**: 음성으로 타이머를 설정하고 시간이 되면 알립니다.

**명령 형식**:
- "숫자 + 분/초 + 타이머"
- "타이머 + 숫자 + 분/초"

**명령 예시**:
- "3분 타이머 맞춰줘"
- "30초 타이머"
- "타이머 5분"

**응답**:
```
"타이머 1 타이머를 3분 후로 설정했습니다."
```

**알림 방식**:
- 설정 시간 후 음성 알림
- "⏰ 타이머 1 타이머가 완료되었습니다!"

#### 6.4.2 타이머 조회
**명령 예시**:
- "타이머 확인"
- "타이머 남은 시간"
- "타이머 봐줘"

**응답 예시**:
```
"활성 타이머:
타이머 1: 2분 30초 남음
타이머 2: 5분 10초 남음"
```

#### 6.4.3 타이머 취소
**명령 예시**:
- "타이머 취소"
- "타이머 1 삭제"
- "타이머 그만"

**응답**:
```
"타이머 1 타이머를 취소했습니다."
```

---

## 7. 일정 관리 기능

### 7.1 일정 추가

#### 7.1.1 자연어 일정 등록
**기능 설명**: 자연스러운 말로 일정을 추가할 수 있습니다.

**지원 형식**:
- "시간 + 일정명"
- "날짜 + 시간 + 일정명"
- "상대적 시간 + 일정명"

**명령 예시**:
```
"오늘 오후 3시 회의"
→ 오늘 15:00에 '회의' 일정 등록

"내일 오전 10시 병원"
→ 내일 10:00에 '병원' 일정 등록

"모레 저녁 7시 저녁 약속"
→ 모레 19:00에 '저녁 약속' 일정 등록
```

#### 7.1.2 시간 파싱
**기능 설명**: 다양한 시간 표현을 자동으로 인식합니다.

**지원 표현**:
- **절대 시간**: "오후 3시", "14시", "오전 10시"
- **상대 날짜**: "오늘", "내일", "모레"
- **요일**: "월요일", "화요일", "다음 주 월요일"
- **조합**: "내일 오후 2시 30분"

**시간 단위**:
- 정시: "3시" → 3:00
- 분 단위: "3시 30분" → 3:30
- 24시간 형식: "14시" → 14:00
- 오전/오후: "오후 3시" → 15:00

#### 7.1.3 자동 리마인더
**기능 설명**: 일정 시간 전에 자동으로 알림을 보냅니다.

**리마인더 시점**:
- 기본: 10분 전
- 설정 변경 가능

**알림 방식**:
- 음성으로 알림
- LED 깜빡임
- 일정 내용 안내

**알림 예시**:
```
"📅 15:00에 '회의' 일정이 있습니다!"
```

### 7.2 일정 조회

#### 7.2.1 오늘 일정 확인
**명령 예시**:
- "오늘 일정 뭐야?"
- "오늘 뭐 해야 해?"
- "일정 확인"

**응답 형식**:
```
"오늘의 일정 2개입니다.
14:00 팀 미팅
18:00 저녁 약속"
```

**정렬**: 시간 순서대로 표시

#### 7.2.2 다가오는 일정 확인
**명령 예시**:
- "내일 일정"
- "이번 주 일정"
- "다음 일정 뭐야?"

**응답 형식**:
```
"다가오는 일정:
2월 4일 10:00 병원
2월 5일 14:00 면접
2월 6일 19:00 저녁 모임"
```

#### 7.2.3 특정 일정 검색
**명령 예시**:
- "회의 일정 언제야?"
- "병원 언제 가?"

**기능**: 일정명으로 검색하여 날짜/시간 알려줌

### 7.3 일정 관리

#### 7.3.1 일정 완료 처리
**명령 예시**:
- "회의 일정 완료"
- "병원 다녀왔어"

**효과**:
- 일정을 완료 상태로 표시
- 완료된 일정은 조회에서 제외

#### 7.3.2 일정 삭제
**명령 예시**:
- "회의 일정 취소"
- "내일 일정 삭제"

**확인 과정**:
1. 삭제할 일정 확인 요청
2. 사용자 확인
3. 삭제 실행

#### 7.3.3 일정 수정
**명령 예시**:
- "회의 시간 4시로 변경"
- "병원 일정 모레로 미뤄"

**처리 방식**:
1. 기존 일정 검색
2. 새로운 정보로 수정
3. 변경 내용 확인

### 7.4 일정 저장

#### 7.4.1 영구 저장
**저장 위치**: `schedules.json`

**저장 시점**:
- 일정 추가 시 즉시 저장
- 일정 변경 시 즉시 저장
- 서버 종료 시 저장

**데이터 형식** (JSON):
```json
{
  "schedules": [
    {
      "id": "uuid-1234",
      "title": "회의",
      "datetime": "2026-02-04T15:00:00",
      "reminder_before": 10,
      "completed": false
    }
  ]
}
```

#### 7.4.2 자동 복원
**기능**: 서버 재시작 시 모든 일정 자동 복원

**복원 내용**:
- 모든 일정 정보
- 리마인더 설정
- 완료 상태

---

## 8. 감정 표현 시스템

### 8.1 감정 분석

#### 8.1.1 감정 감지
**기능 설명**: 대화 내용에서 사용자의 감정을 자동으로 파악합니다.

**감지 방법**:
- 키워드 기반 감정 분석
- 문맥 이해
- 감탄사 인식
- 이모티콘 인식

**분석 예시**:
```
"정말 기뻐!" → happy
"슬퍼..." → sad
"너무 신나!" → excited
"피곤해" → sleepy
"짜증나" → angry
"괜찮아" → neutral
```

#### 8.1.2 감정 키워드
**각 감정별 키워드**:

**happy (행복)**:
- 기쁘다, 좋다, 행복하다, 만족하다
- 최고, 환상적, 멋지다

**sad (슬픔)**:
- 슬프다, 우울하다, 힘들다
- 안타깝다, 속상하다

**excited (흥분)**:
- 신나다, 설레다, 흥미롭다
- 재미있다, 대박

**sleepy (졸림)**:
- 졸리다, 피곤하다, 지치다
- 쉬고 싶다

**angry (화남)**:
- 화나다, 짜증나다, 싫다
- 답답하다

**neutral (중립)**:
- 기본 상태
- 특별한 감정 표현 없음

### 8.2 LED 감정 표현

#### 8.2.1 감정별 LED 색상
**기능 설명**: RGB LED로 현재 감정을 시각적으로 표현합니다.

**색상 매핑**:
- **happy**: 노란색 (255, 200, 0) - 밝고 따뜻한 느낌
- **sad**: 파란색 (0, 100, 255) - 차갑고 우울한 느낌
- **excited**: 핑크색 (255, 0, 200) - 화려하고 활발한 느낌
- **sleepy**: 보라색 (100, 0, 200) - 어둡고 차분한 느낌
- **angry**: 빨간색 (255, 0, 0) - 강렬하고 격한 느낌
- **neutral**: 초록색 (0, 255, 100) - 평온하고 안정적

#### 8.2.2 LED 패턴
**각 감정별 점멸 패턴**:

**happy**: 
- 빠른 깜빡임
- 밝게 → 어둡게 반복
- 경쾌한 느낌

**sad**:
- 느린 깜빡임
- 서서히 어두워짐
- 우울한 느낌

**excited**:
- 매우 빠른 깜빡임
- 무지개 효과
- 활발한 느낌

**sleepy**:
- 매우 느린 깜빡임
- 점점 어두워짐
- 졸린 느낌

**angry**:
- 불규칙한 깜빡임
- 강한 명암 대비
- 격한 느낌

**neutral**:
- 고정된 색상
- 깜빡임 없음
- 차분한 느낌

### 8.3 서보 감정 표현

#### 8.3.1 감정별 동작
**기능 설명**: 서보 모터로 감정에 맞는 제스처를 표현합니다.

**동작 매핑**:

**happy (끄덕이기)**:
- 상하 움직임
- 70° → 110° 반복
- 빠른 속도
- 의미: 긍정, 동의

**sad (천천히 좌우)**:
- 좌우 움직임
- 60° → 120° 반복
- 느린 속도
- 의미: 부정, 슬픔

**excited (빠른 흔들기)**:
- 빠른 좌우 움직임
- 30° → 150° 반복
- 매우 빠른 속도
- 의미: 흥분, 기대

**sleepy (천천히 하강)**:
- 위에서 아래로
- 110° → 70°
- 매우 느린 속도
- 의미: 졸음, 피곤

**angry (급격한 움직임)**:
- 불규칙한 좌우
- 40° → 140° 급격히
- 빠르고 격한 움직임
- 의미: 화남, 짜증

**neutral (중앙 위치)**:
- 고정 위치
- 90° 유지
- 움직임 없음
- 의미: 중립, 대기

#### 8.3.2 동작 실행
**처리 과정**:
1. 감정 분석 완료
2. 감정 명령 생성
3. ESP32로 전송
4. LED 색상 변경
5. 서보 동작 실행
6. 동시 실행으로 통합 표현

### 8.4 감정 상태 관리

#### 8.4.1 감정 전환
**기능 설명**: 대화에 따라 감정이 자연스럽게 변화합니다.

**전환 시점**:
- 새로운 감정 키워드 감지 시
- 대화 맥락 변화 시
- 사용자 명시적 요청 시

**전환 효과**:
- LED 색상 부드럽게 전환
- 서보 동작 전환
- 음성 톤 변화 (TTS)

#### 8.4.2 감정 지속
**기능 설명**: 한 번 설정된 감정이 일정 시간 유지됩니다.

**지속 시간**: 5분 (기본)

**자동 복귀**:
- 지속 시간 경과 후 neutral로 복귀
- 새로운 감정 감지 시까지 유지

**설정 변경** (`config.yaml`):
```yaml
emotion:
  enabled: true
  decay_to_neutral: true
  decay_interval: 300  # 초 단위
```

#### 8.4.3 감정 비활성화
**기능 설명**: 감정 시스템을 끌 수 있습니다.

**설정 방법** (`config.yaml`):
```yaml
emotion:
  enabled: false
```

**비활성화 시**:
- 감정 분석 하지 않음
- LED는 기본 색상 유지
- 서보는 명령에만 반응

---

## 9. 프로액티브 상호작용

### 9.1 자발적 대화

#### 9.1.1 프로액티브 모드
**기능 설명**: 사용자가 말을 걸지 않아도 AI가 먼저 말을 겁니다.

**특징**:
- 정기적으로 메시지 전송
- 시간대별 적절한 인사
- 상황에 맞는 대화
- 펫처럼 친근한 느낌

**활성화 조건**:
- 에이전트 모드일 때만 작동
- 설정에서 활성화된 경우
- 일정 시간 침묵 후

#### 9.1.2 대화 시점
**기능 설명**: 설정된 간격마다 자동으로 말을 겁니다.

**기본 간격**: 10분 (600초)

**시점 결정**:
- 마지막 대화로부터 경과 시간
- 시간대 (아침, 점심, 저녁)
- 무작위 요소 추가

**설정 변경** (`config.yaml`):
```yaml
assistant:
  proactive: true
  proactive_interval: 600  # 초 단위
```

**간격 조정 예시**:
- 5분마다: 300
- 15분마다: 900
- 30분마다: 1800
- 1시간마다: 3600

### 9.2 프로액티브 메시지 유형

#### 9.2.1 시간대별 인사
**기능 설명**: 하루 중 시간대에 맞는 인사를 합니다.

**아침 (6:00~11:59)**:
- "좋은 아침이에요!"
- "잘 주무셨나요?"
- "오늘도 좋은 하루 보내세요!"
- "아침 식사하셨어요?"

**오후 (12:00~17:59)**:
- "안녕하세요!"
- "점심 맛있게 드셨나요?"
- "오후도 힘내세요!"
- "잠깐 쉬면서 이야기할까요?"

**저녁 (18:00~21:59)**:
- "저녁 식사 하셨나요?"
- "오늘 하루 어떠셨어요?"
- "피곤하시죠?"
- "편안한 저녁 보내세요!"

**밤 (22:00~05:59)**:
- "아직 안 주무세요?"
- "늦은 시간이네요"
- "푹 쉬세요"
- "내일 봐요!"

#### 9.2.2 침묵 후 멘트
**기능 설명**: 오래 침묵하면 관심을 끌기 위해 말을 겁니다.

**멘트 예시**:
- "심심해요. 뭐 하세요?"
- "저 여기 있어요!"
- "이야기 좀 해요"
- "무슨 생각 하세요?"
- "저랑 놀아주세요"

**발동 조건**:
- 프로액티브 간격 경과
- 에이전트 모드
- 사용자 활동 없음

#### 9.2.3 활동 제안
**기능 설명**: 재미있는 활동이나 주제를 제안합니다.

**제안 예시**:
- "날씨가 좋은데 산책 어때요?"
- "뉴스 들어보실래요?"
- "재미있는 얘기 하나 해드릴까요?"
- "오늘 일정 확인해드릴까요?"
- "타이머 필요하세요?"

#### 9.2.4 기분 체크
**기능 설명**: 사용자의 기분을 확인하고 관심을 표현합니다.

**멘트 예시**:
- "기분이 어떠세요?"
- "오늘 좋은 일 있었나요?"
- "힘든 일 있으면 말해주세요"
- "필요한 게 있으면 말씀해주세요"

### 9.3 프로액티브 설정

#### 9.3.1 활성화/비활성화
**활성화** (`config.yaml`):
```yaml
assistant:
  proactive: true
```

**비활성화**:
```yaml
assistant:
  proactive: false
```

**효과**:
- true: 정기적으로 말을 검
- false: 사용자가 말할 때만 반응

#### 9.3.2 간격 조정
**빈도 높이기** (자주 말 걸기):
```yaml
assistant:
  proactive_interval: 300  # 5분
```

**빈도 낮추기** (가끔 말 걸기):
```yaml
assistant:
  proactive_interval: 3600  # 1시간
```

**권장 설정**:
- 펫 느낌: 300~600초 (5~10분)
- 어시스턴트 느낌: 1800~3600초 (30분~1시간)

#### 9.3.3 메시지 커스터마이징
**위치**: `server/proactive_interaction.py`

**수정 방법**:
1. 파일 열기
2. 메시지 목록 찾기
3. 원하는 멘트 추가/수정
4. 서버 재시작

**예시**:
```python
morning_greetings = [
    "좋은 아침이에요!",
    "안녕하세요!",
    "당신이 추가한 인사말"  # 추가
]
```

---

## 10. 시스템 관리 및 모니터링

### 10.1 로깅 시스템

#### 10.1.1 콘솔 로그
**기능 설명**: 실시간으로 시스템 상태를 콘솔에 표시합니다.

**로그 레벨**:
- **DEBUG**: 상세한 디버그 정보
- **INFO**: 일반 정보 메시지
- **WARNING**: 경고 메시지
- **ERROR**: 오류 메시지

**컬러 코딩**:
- DEBUG: 회색
- INFO: 흰색
- WARNING: 노란색
- ERROR: 빨간색

**로그 형식**:
```
2026-02-03 14:30:00 | INFO | module_name | 메시지 내용
```

#### 10.1.2 파일 로그
**기능 설명**: 모든 로그를 파일로 저장합니다.

**로그 디렉토리**: `logs/`

**파일 종류**:
1. **일반 로그**: `app_YYYYMMDD.log`
   - 모든 레벨의 로그
   - 일별로 자동 생성
   - 무제한 보관

2. **에러 로그**: `error_YYYYMMDD.log`
   - ERROR 레벨만
   - 문제 추적 용이
   - 별도 보관

**로그 예시**:
```
2026-02-03 14:30:00 | INFO | stt_engine | STT processing completed in 0.85s
2026-02-03 14:30:01 | INFO | agent_mode | LLM response generated in 1.23s
2026-02-03 14:30:02 | ERROR | connection | Client disconnected unexpectedly
```

#### 10.1.3 로그 설정
**로그 레벨 변경** (`config.yaml`):
```yaml
logging:
  level: "INFO"  # DEBUG, INFO, WARNING, ERROR
  save_to_file: true
  log_dir: "logs"
```

**개발 시**:
```yaml
logging:
  level: "DEBUG"  # 모든 상세 정보
```

**운영 시**:
```yaml
logging:
  level: "WARNING"  # 경고 이상만
```

### 10.2 성능 모니터링

#### 10.2.1 응답 시간 추적
**기능 설명**: 각 컴포넌트의 처리 시간을 자동으로 측정합니다.

**추적 항목**:
- **STT 시간**: 음성 → 텍스트 변환 시간
- **LLM 시간**: AI 응답 생성 시간
- **TTS 시간**: 텍스트 → 음성 변환 시간
- **총 응답 시간**: 전체 파이프라인

**로그 출력**:
```
STT processing completed in 0.85s
LLM response generated in 1.23s
TTS conversion completed in 1.45s
Total response time: 3.53s
```

#### 10.2.2 성능 통계
**기능 설명**: 서버 종료 시 누적 통계를 표시합니다.

**통계 항목**:
- 총 요청 수
- 평균 처리 시간
- 최소/최대 시간
- 에러 발생 횟수

**통계 출력** (Ctrl+C로 종료 시):
```
==================================================
Performance Statistics
--------------------------------------------------
STT Requests: 45 (avg: 0.85s, min: 0.52s, max: 1.20s)
LLM Requests: 45 (avg: 1.23s, min: 0.80s, max: 2.10s)
TTS Requests: 30 (avg: 1.45s, min: 1.10s, max: 2.05s)
Errors: 2
Uptime: 2h 15m 30s
==================================================
```

#### 10.2.3 리소스 사용
**메모리 사용량**:
- STT 모델: ~500MB~2GB (모델 크기별)
- LLM 모델: ~1GB
- 런타임 오버헤드: ~500MB
- **총합**: 2~4GB

**GPU 사용**:
- CUDA 활성화 시 자동 사용
- VRAM: 2~4GB
- 처리 속도 5~10배 향상

**CPU 사용**:
- CUDA 없을 시 CPU 사용
- 멀티코어 활용
- 속도는 느리지만 작동 가능

### 10.3 연결 관리

#### 10.3.1 연결 상태 모니터링
**기능 설명**: ESP32 연결 상태를 실시간으로 추적합니다.

**상태 종류**:
- **연결됨**: 정상 통신 중
- **연결 끊김**: 네트워크 문제
- **재연결 중**: 자동 복구 시도

**로그 메시지**:
```
Client connected from 192.168.1.150:12345
Connection lost, waiting for reconnection...
Client reconnected successfully
```

#### 10.3.2 자동 재연결
**기능 설명**: 연결이 끊겼을 때 자동으로 복구합니다.

**ESP32 측**:
- 연결 끊김 감지
- 5초 후 재시도
- 무한 재시도

**서버 측**:
- 끊긴 연결 정리
- 새 연결 대기
- 컨텍스트 유지

#### 10.3.3 타임아웃 설정
**설정 위치** (`config.yaml`):
```yaml
connection:
  socket_timeout: 0.5  # 초 단위
```

**타임아웃 조정**:
- 짧게: 빠른 응답, 불안정
- 길게: 안정적, 느린 응답
- 권장: 0.5~1.0초

### 10.4 오디오 품질 관리

#### 10.4.1 오디오 저장
**기능 설명**: 녹음된 오디오를 WAV 파일로 저장합니다.

**저장 위치**: `wav_logs/`

**파일명 형식**: `YYYYMMDD_HHMMSS.wav`

**용도**:
- 인식 오류 디버깅
- 음질 확인
- 테스트 데이터 수집

**활성화/비활성화**:
- 코드에서 `save_audio=True` 파라미터로 제어
- 디버깅 시에만 활성화 권장

#### 10.4.2 품질 메트릭
**측정 항목**:
- **RMS (Root Mean Square)**: 평균 음량
- **Peak**: 최대 진폭
- **SNR (Signal-to-Noise Ratio)**: 신호 대 잡음비 (추정)

**품질 기준**:
- RMS > 100: 충분한 음량
- Peak > 500: 명확한 신호
- Length > 300ms: 충분한 길이

**품질 불량 시**:
- 경고 로그 출력
- 인식 건너뜀
- 사용자에게 재시도 유도

### 10.5 설정 관리

#### 10.5.1 통합 설정 파일
**파일**: `server/config.yaml`

**구조**:
```yaml
# 서버 설정
server:
  host: "0.0.0.0"
  port: 5001

# STT 설정
stt:
  model_size: "small"
  device: "cuda"
  language: "ko"

# LLM 설정
llm:
  model_name: "Qwen/Qwen2.5-0.5B-Instruct"
  device: "cuda"

# TTS 설정
tts:
  voice: "ko-KR-SunHiNeural"

# 어시스턴트 설정
assistant:
  name: "아이"
  personality: "cheerful"
  proactive: true
  proactive_interval: 600

# 기타 설정...
```

#### 10.5.2 환경 변수
**파일**: `server/.env`

**내용**:
```bash
WEATHER_API_KEY=your_api_key_here
SERVER_PORT=5001
DEVICE=cuda
ASSISTANT_NAME=아이
LOG_LEVEL=INFO
```

**장점**:
- 민감한 정보 분리
- 환경별 설정 관리
- Git에 포함하지 않음 (`.gitignore`)

#### 10.5.3 설정 검증
**기능 설명**: 서버 시작 시 설정 파일을 자동으로 검증합니다.

**검증 항목**:
- 필수 항목 존재 여부
- 타입 확인
- 값 범위 확인
- 파일 경로 존재 확인

**검증 실패 시**:
- 오류 메시지 출력
- 기본값 사용 또는 종료
- 문제 항목 명시

### 10.6 에러 처리

#### 10.6.1 예외 처리
**기능 설명**: 모든 주요 기능에 예외 처리가 구현되어 있습니다.

**처리 방식**:
- 예외 catch
- 에러 로그 기록
- 사용자 친화적 메시지
- 복구 시도 또는 우아한 종료

**에러 예시**:
```python
try:
    result = stt_engine.transcribe(audio)
except Exception as e:
    logger.error(f"STT failed: {e}")
    return "인식에 실패했습니다. 다시 말씀해주세요."
```

#### 10.6.2 복구 메커니즘
**자동 복구**:
- 네트워크 연결 끊김: 자동 재연결
- 모델 로딩 실패: CPU로 폴백
- 파일 오픈 실패: 재시도
- API 호출 실패: 캐시 사용

**수동 개입 필요**:
- 설정 파일 오류
- 모델 파일 누락
- 권한 문제

#### 10.6.3 디버깅
**디버그 모드 활성화**:
```yaml
logging:
  level: "DEBUG"
```

**디버그 정보**:
- 상세한 처리 과정
- 변수 값
- 호출 스택
- 타이밍 정보

**문제 해결 순서**:
1. 로그 파일 확인 (`logs/error_*.log`)
2. 에러 메시지 분석
3. 설정 파일 검증
4. 네트워크 연결 확인
5. 모델 파일 확인
6. 재시작 시도

---

## 📋 부록

### A. 지원 명령어 요약

#### A.1 로봇 모드 명령
- **위치**: 가운데, 왼쪽, 오른쪽
- **상대 이동**: 올려, 내려
- **각도**: "45도", "120"
- **동작**: 회전, 멈춰

#### A.2 정보 조회 명령
- **시간**: "지금 몇 시?", "오늘 날짜?"
- **날씨**: "날씨 어때?", "밖에 춥니?"
- **뉴스**: "뉴스 알려줘"

#### A.3 타이머 명령
- **설정**: "3분 타이머", "30초 타이머"
- **조회**: "타이머 확인", "남은 시간"
- **취소**: "타이머 취소"

#### A.4 일정 명령
- **추가**: "오늘 3시 회의", "내일 병원"
- **조회**: "오늘 일정", "내일 일정"
- **관리**: "일정 완료", "일정 취소"

### B. 문제 해결

#### B.1 연결 문제
**증상**: ESP32가 서버에 연결되지 않음

**해결 방법**:
1. WiFi 연결 확인
2. 서버 IP 주소 확인
3. 방화벽 설정 (5001 포트 허용)
4. 같은 네트워크에 있는지 확인
5. 서버가 실행 중인지 확인

#### B.2 음성 인식 문제
**증상**: 말을 해도 인식이 안 됨

**해결 방법**:
1. VAD 임계값 조정
2. 마이크 소리 크기 확인
3. 주변 소음 줄이기
4. STT 모델 크기 증가
5. GPU 사용 확인

#### B.3 느린 응답
**증상**: 응답이 너무 느림

**해결 방법**:
1. GPU 활성화 확인
2. STT 모델 크기 감소
3. LLM 모델 경량화
4. CPU 성능 확인
5. 메모리 확인

#### B.4 날씨 정보 안 나옴
**증상**: 날씨 조회 시 에러

**해결 방법**:
1. API 키 확인
2. API 키 활성화 확인 (몇 시간 소요)
3. 인터넷 연결 확인
4. 도시명 영문 확인

### C. 성능 최적화

#### C.1 GPU 활용
**CUDA 설치**:
1. NVIDIA GPU 드라이버 설치
2. CUDA Toolkit 설치
3. PyTorch GPU 버전 설치
4. `config.yaml`에서 `device: "cuda"` 설정

**효과**:
- STT 속도 5~10배 향상
- LLM 속도 3~5배 향상
- 전체 응답 시간 단축

#### C.2 모델 선택
**STT 모델 권장**:
- GPU 있음: `small` 또는 `base`
- CPU만: `tiny`
- 높은 정확도 필요: `medium`

**메모리 vs 성능**:
- tiny: 39MB, 빠름, 낮은 정확도
- small: 244MB, 균형, 추천
- medium: 769MB, 느림, 높은 정확도

#### C.3 네트워크 최적화
**WiFi 최적화**:
- 2.4GHz 사용 (안정성)
- 라우터와 가까운 위치
- 채널 혼잡도 확인

**패킷 크기**:
- 기본 설정으로 충분
- 네트워크 불안정 시 크기 감소

### D. 확장 아이디어

#### D.1 하드웨어 확장
- 추가 서보 모터 (다자유도)
- 디스플레이 추가 (OLED)
- 센서 추가 (온도, 습도, 거리)
- 카메라 모듈 (비전)

#### D.2 소프트웨어 확장
- 웨이크워드 감지 ("헤이 아이")
- 다국어 지원
- 사용자별 개인화
- 학습 기능

#### D.3 통합 확장
- Home Assistant 연동
- MQTT 지원
- 웹 대시보드
- 모바일 앱

---

## 🎓 마치며

이 가이드는 LLM_Arduino 프로젝트의 모든 기능을 체계적으로 설명합니다. 

**기능 요약**:
- ✅ 음성 인식 및 합성
- ✅ 로봇 제어
- ✅ AI 대화
- ✅ 정보 서비스
- ✅ 일정 관리
- ✅ 감정 표현
- ✅ 자발적 상호작용
- ✅ 시스템 모니터링

**프로젝트 특징**:
- 오픈소스
- 로컬 실행 가능
- 확장 가능
- 사용자 친화적

**활용 분야**:
- 홈 어시스턴트
- 스마트 펫
- 교육용 로봇
- IoT 프로젝트

더 자세한 정보는 다른 문서들을 참고하세요:
- `README.md`: 프로젝트 개요
- `SYSTEM_ARCHITECTURE.md`: 시스템 구조
- `PROTOCOL.md`: 통신 프로토콜
- `USER_GUIDE.md`: 빠른 시작 가이드

---

**문서 버전**: 1.0  
**최종 업데이트**: 2026-02-03  
**작성자**: LLM_Arduino Project Team
